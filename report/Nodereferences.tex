\chapter{Complete node reference}

FunctionDeclNode \tab{\inlinecode{def f(...):}} \\
ClassDeclNode 	\tab{\inlinecode{class c(...):}} \\
ClassEntryNode\\
FunctionEntryNode\\
ExitNode\\
ConstantBooleanNode\\
ConstantIntNode\\
ConstantFloatNode\\
ConstantLongNode\\
ConstantComplexNode\\
ConstantStringNode\\
ConstantNoneNode \tab{\inlinecode{None}} \\
ReadVariableNode \tab{\inlinecode{x}} \\
ReadPropertyNode \tab{\inlinecode{$reg_{obj}$.property}} \\
ReadIndexableNode \tab{\inlinecode{$reg_{obj}$[$reg_{index}$]}} \\
WriteVariableNode \tab{\inlinecode{x = value}} \\
WritePropertyNode \tab{\inlinecode{$reg_{obj}$.property = value}} \\
WriteIndexableNode \tab{\inlinecode{$reg_{obj}$[$reg_{index}$] = value}} \\
DelVariableNode \tab{\inlinecode{del x}} \\
DelPropertyNode \tab{\inlinecode{del $reg_{obj}$.property}} \\
DelIndexableNode \tab{\inlinecode{del $reg_{obj}$[$reg_{index}$]}} \\
NoOpNode \\ 
CallNode \tab{\inlinecode{$reg_{function}$($reg_1$, ..., $reg_n$)}} \\
ReturnNode \tab{\inlinecode{return $reg_{value}$}} \\
CompareOpNode \tab{\inlinecode{$reg_{left}$ $op_{comp}$ $reg_{right}$}} \\
BinOpNode \tab{\inlinecode{$reg_{left}$ $op_{binop}$ $reg_{right}$}} \\
IfNode \tab{\inlinecode{if $reg_{cond}$, while $reg_{cond}$:}} \\
RaiseNode \tab{\inlinecode{raise $reg_{exception}$}} \\
ExceptNode \tab{\inlinecode{except ($type_1$, ..., $type_n$):}}