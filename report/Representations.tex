\chapter{Monotone framework implementation}

To get started on the implementation we have made a brief implementation of the monotone framework that is decoupled from the actual analysis.
This implementation counts commonly used lattice structures, the work list algorithm, a graph structure and an analysis interface (or trait in scala-lingo).

\section{Lattices}

In order to make our lives easier when constructing the final analysis lattice, we have implemented several common lattice structures as type generic classes. 
These common lattice structures include, among others, a map- and product lattice. 
In this section we will briefly go over the implementation decisions made for these structures.

Using classic OOP principles each of these compound structures decide the ordering of their elements by delegating to the underlying lattices in a point wise fashion, 
e.g. the product lattice has two underlying lattices, 
one for each element and thus the ordering is decided by comparing the first element in the pair in the context of the first lattice and similarly for the second element.

The map lattice has received a couple changes from the native implementation to make it usable in more cases. 
The first change was to interpret an unbound key value, k, to be a mapping from k to the bottom element of the underlying lattice. 
In some use cases, such as a functional approach to intra procedural static analysis, the map lattice will have a huge amount of keys. 
Requiring all of these to be bound to some value in the map is superfluous. 
This invariant is hidden completely in the lattice class because you can't manipulate the lattice element directly, 
so when trying to lookup an unbound key, the lattice simply constructs a fresh bottom value.

Since we now have a way to avoid binding every value from the key set, we are also able to change the constructor 
from the straightforward approach s: \inlinecode{Set[T]}, l: \inlinecode{Lattice[S]} into a more general s: \inlinecode{T}, l: \inlinecode{Lattice[S]} 
(where \inlinecode{S} and \inlinecode{T} are type arguments). The straightforward approach has to computing the entire key set before you are able to 
instantiate the map lattice, but since the key set in itself might be exponentially large that wouldn't be practical. The downside to this change is, 
that since map lattice has no way to know the intended key set, there is no way to construct the top element of the lattice.

The top element of the lattice is useful for when you want to give up in the analysis, so to fix we instrumented the map lattice with a new top element, 
in a similar fashion to how the sink lattice instruments the underlying lattice with a new bottom element. 

\section{Constraints}

Being in a functional programming language an easy to work with representation of the constraints is anonymous lambdas with the type \inlinecode{E $\rightarrow$ E}, 
where \inlinecode{E} is the type of the elements in the analysis lattice. Each constraint captures the node it was made from in its closure, 
so it is able to lookup the needed information in the lattice element.

This approach follows the notation very nicely, and as such makes the implementation a simple task when the constraints have been formulated formally.

\section{Worklist}
Our work list implementation hasn't seen any optimizations and as such is just the straightforward implementation. First it generates constraint functions for each of the nodes in the controlflow graph, adding each node to a work list as it goes along. It then starts recursion (scala benefits from tail call optimization to prevent the stack from exploding) on the list, popping one node from the list at a time. When a node is popped the corresponding constraint function is applied to the solution. Using scalas built-in structural equality, the result is compared to the input and if they differ all nodes that depends on the popped node are added to the work list.

A simple optimization would be to focus on finding a fixed point for a strongly connected component of the control flow graph before continuing with the strongly connected components that depend on it.


