\chapter{Monotoneframework implementation}

To get started on the implementation we have made a brief implemtation of the monotone framework that is decoupled from the actual analysis.
This implementation counts commonly used lattice structures, the worklist algorithm, a graph structure and an analysis interface (or trait in scala-lingo).

\section{Lattices}

In order to make our lives easier when constructing the final analysis lattice, we have implemented several common lattice structures as type generic classes. These common lattice structures include, among others, a map- and product lattice. In this section we will briefly go over the implementation decisions made for these structures.

Using classic OOP principles each of these compound structures decide the ordering of their elements by delegating to the underlying lattices in a point wise fashion, e.g. the product lattice has two underlying lattices, one for each element and thus the ordering is decided by comparing the first element in the pair in the context of the first lattice and similarly for the second element.

The map lattice has received a couple changes from the native implementation to make it usable in more cases. The first change was to interpret an unbound key value, k, to be a mapping from k to the bottom element of the underlying lattice. In some use cases, such as a functional approach to intra procedural static analysis, the map lattice will have a huge amount of keys. Requiring all of these to be bound to some value in the map is superfluous. This invariant is hidden completely in the lattice class because you can't manipulate the lattice element directly, so when trying to lookup an unbound key, the lattice simply constructs a fresh bottom value.

Since we now have a way to not bind every value from the key set, we are also able to change the constructor from the straightforward approach s: Set[T], l: Lattice[S] into a more general s: T, l: Lattice[S] (where S and T are type arguments). The straightforward approach has to computing the entire key set before you are able to instantiate the map lattice, but since the key set in itself might be exponentially large that wouldn't be practical. The downside to this change is, that since map lattice has no way to know the intended key set, there is no way to construct the top element of the lattice.

The top element of the lattice is useful for when you want to give up in the analysis, so to fix we instrumented the map lattice with a new top element, in a similar fashion to how the sink lattice instruments the underlying lattice with a new bottom element. 

<powersub/super>


\section{Constraints}

Being in a functional programming language an easy to work with representation of the constraints is anonymous lambdas with the type E -> E, where E is the type of the elements in the analysis lattice. Each constraint captures the node it was made from in its closure, so it is able to lookup the needed information in the lattice element.

This approach follows the notation very nicely, and as such makes the implementation a simple task when the constraints have been formulated formally.

